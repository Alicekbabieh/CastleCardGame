<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Castle Card Game â€” 3 face-down only</title>
<style>
:root{
  --card-gap:14px;
  --stack-gap:16px;
  --board-padding:12px;
  --bg:#156515;
  --board-w:980px;
  --card-w:82px;
  --card-h:116px;
  --accent:#ffd24d;
  --back-blue:linear-gradient(135deg,#0f3ba6,#0a2a7a);
}
*{box-sizing:border-box;}
body{
  margin:0; font-family:Inter, Arial, sans-serif; background:var(--bg); color:#fff;
  display:flex; align-items:flex-start; justify-content:center; padding:20px;
}
.row-center { 
  display:flex; 
  align-items:center; 
  justify-content:center; 
  gap:20px; 
}

.board{
  width:100%; 
  max-width:var(--board-w); 
  background: linear-gradient(180deg,#1e6b1e,#0f3b0f);
  border-radius:12px;
  box-shadow:0 10px 40px rgba(0,0,0,0.6); 
  padding:var(--board-padding); 
  text-align:center;
}
h1{ margin:6px 0 12px; text-shadow:0 2px 6px rgba(0,0,0,0.6); font-size:22px; }
.zone{ 
    display:flex; 
    flex-direction: column; 
    align-items:center; 
    justify-content: flex-start;  
    gap:12px; 
}
.panel{ 
    display: flex;
    flex-direction: column;
    align-items: center;
    margin-bottom: 4px;
}
.hand{ 
  display:flex; 
  gap:var(--card-gap);; 
  justify-content:center; 
  flex-wrap:wrap; 
  min-height:var(--card-h); 
  padding:8px; 
}

.hidden-row{ 
  display:flex; 
  gap:12px; 
  justify-content:center; 
  padding:4px 8px 0 8px; 
  min-height:48px; 
}

.card{
  width:var(--card-w); height:var(--card-h); border-radius:8px; background:#fff; color:#000;
  display:flex; align-items:center; justify-content:center; font-weight:800; font-size:20px;
  box-shadow:2px 8px 18px rgba(0,0,0,0.55); user-select:none; cursor:pointer;
  transition: transform 0.12s ease, box-shadow 0.12s ease;
}
.card.red{ color:#c71c23; }

/* BACK of card style (used for face-down cards) */
.card.back{
  background: var(--back-blue);
  color: transparent;
  border: 2px solid rgba(255,255,255,0.14);
  box-shadow: inset 0 -6px 12px rgba(0,0,0,0.25), 2px 8px 18px rgba(0,0,0,0.55);
}

/* face-up look for normal hand/faceup cards (white with suit) */
.card.face { background: #fff}
.card.face.red { color: #c71c23; }

.card.hidden-clickable{ cursor:pointer; box-shadow: 0 0 0 3px rgba(255,255,0,0.08); }
.card.playable{ box-shadow:0 0 0 4px rgba(255,255,0,0.12), 2px 8px 18px rgba(0,0,0,0.55); }
.card.selected{ outline:3px solid orange; outline-offset:-6px; transform: translateY(-6px); }
.card.swap-selected{ outline:3px solid blue; outline-offset:-6px; }

#pile {
  width: var(--card-w); height: var(--card-h); position: relative; border-radius: 12px; background: rgba(255,255,255,0.06); border: 3px solid #fff; display:flex; align-items: flex-start; justify-content:center; overflow: visible;
}
.pile-card{
  position:absolute;
  width:var(--card-w); height:var(--card-h);
  border-radius:10px;
  display:flex; align-items:center; justify-content:center;
  font-weight:900; font-size:22px;
  box-shadow:0px 8px 24px rgba(0,0,0,0.9);
  background:#fff; color:#000;
  transition: all 0.18s ease;
}
.pile-card.red { color:#c71c23; }
.pile-card.top {
  border: 4px solid yellow;
  transform: translate(0, -14px) scale(1.08);
  z-index: 5000;
  box-shadow: 0px 12px 35px rgba(0,0,0,1);
}

/* stacked layout: facedown row on top visually sits under faceup */
.stack { 
  position: relative; 
  width: 320px; 
  height: 160px; 
}
.facedown-row, .faceup-row { 
  position:absolute; 
  left:0; 
  width:100%; 
  display:flex; 
  justify-content:center; 
  gap:var(--stack-gap); 
}
.facedown-row { top: 40px; z-index: 1; }
.faceup-row   { top: 0px;  z-index: 2; }
.faceup-row .card { margin-top: -20; }

#deck{ width:var(--card-w); height:var(--card-h); margin:10px auto; background:#6b3b1b; display:flex; align-items:center; justify-content:center; border-radius:8px; font-weight:700; cursor:pointer; box-shadow:2px 8px 18px rgba(0,0,0,0.6); }
#pile-count { margin-top:8px; font-weight:700; color:var(--accent); }
.controls{ margin-top:14px; display:flex; justify-content:center; gap:10px; flex-wrap:wrap; }
button{ padding:10px 14px; font-size:15px; border-radius:8px; cursor:pointer; border:0; background:#2b7a2b; color:#fff; }
button:disabled{ opacity:0.45; cursor:not-allowed; }
#status{ margin-top:12px; font-weight:700; }
#winner{ margin-top:12px; font-size:20px; color:gold; font-weight:900; }
.label { font-size:14px; margin:6px 0 0 0; color:#fff; opacity:0.95; }
@media(max-width:840px){
  :root { --card-w:70px; --card-h:98px; }
  .board{ padding:12px; }
  h1{ font-size:18px; }
  #pile { width:150px; height:200px; }
}
</style>
</head>
<body>
<div class="board" id="board">
  <h1> Castle Card Game </h1>
  <div class="zone" >
    <div class="panel">
        <h3 class="label">CPU</h3>
        <div class="stack">
          <div id="cpu-flipped" class="facedown-row"></div>
          <div id="cpu-faceup" class="faceup-row"></div>
        </div>
        <div id="cpu-hand" class="hand"></div>
    </div>
    <div class="row-center">
      <div id="deck-wrapper" style="display:flex; flex-direction:column; align-items:center;">
            <div id="deck" title="Draw from deck">Deck</div>
        </div>
        <div id="pile-wrapper" style="display:flex; flex-direction:column; align-items:center;">
            <h3 class="label">Discard Pile</h3>
            <div id="pile"></div>
            <div id="pile-count"></div>
        </div>
      </div>
    <div class="panel">
        <h3 class="label">You</h3>
        <div class="stack">
          <div id="player-flipped" class="facedown-row"></div>
          <div id="player-faceup" class="faceup-row"></div>
        </div>
        <div id="player-hand" class="hand"></div>
      </div>   
  </div>

  <div class="controls">
    <button id="swapBtn">Swap Hand & Face-Up Cards</button>
    <button id="playBtn">Play Selected Card(s)</button>
    <button id="pickupBtn">Pick Up Pile</button>
    <button id="startBtn">Start Game</button>
    <button id="newBtn">New Game</button>
  </div>

  <div id="status"></div>
  <div id="winner"></div>
</div>
<script>

/*  Game state  */
const suits = ['â™ ','â™¥','â™¦','â™£'];
const values = ['2','3','4','5','6','7','8','9','10','J','Q','K','A'];

let deck = [], players = [], pile = [], selectedIndices = [], currentPlayer = 0;
let awaitingRestart = null;
let resetNext = false, sevenConstraint = false, gameOver = false;
let isPreGame = true;
let selectedSwapHand = null;
let selectedSwapFaceup = null;

/*  Helpers  */
function createDeck(){
  deck = [];
  for(const s of suits) 
    for(const v of values) 
      deck.push({suit:s, value:v});
}

function shuffle(a){
  for(let i=a.length-1;i>0;i--){
    const j = Math.floor(Math.random()*(i+1));
    [a[i], a[j]] = [a[j], a[i]];
  }
}
function idxOf(v){ return values.indexOf(String(v)); }
function topCard(){ return pile.length ? pile[pile.length-1] : null; }

/*  Start / refill  */
function startGame(){
  deck = []; players = []; pile = []; selectedIndices = [];
  currentPlayer = 0; awaitingRestart = null; resetNext = false; sevenConstraint = false; gameOver = false;
  isPreGame = true;
  createDeck(); shuffle(deck);
  players = [
    { name:'You', hand:[], faceup:[], flipped:[], cpu:false },
    { name:'CPU', hand:[], faceup:[], flipped:[], cpu:true }
  ];
  // deal: flipped (3 face-down top), faceup (3 visible middle), hand (3)
  for(const p of players){
    p.flipped = deck.splice(0,3);
    p.faceup = deck.splice(0,3);
    p.hand = deck.splice(0,3);
  }
  renderAll();
  setStatusOnce("Pre-game: flipped cards are face-down. Click Start Game when ready.");
}
function refill(i){
  const p = players[i];
  while(p.hand.length < 3 && (deck.length > 0 || p.faceup.length > 0 || p.flipped.length > 0)){
    if(deck.length > 0) p.hand.push(deck.pop());
    else if(p.faceup.length > 0) p.hand.push(p.faceup.pop());
    else if(p.flipped.length > 0) p.hand.push(p.flipped.pop());
    else break;
  }
}

/* ---------- Rendering ---------- */
function makeCardElement(card){
  const el = document.createElement('div');
  el.className = 'card face' + ((card.suit==='â™¥'||card.suit==='â™¦') ? ' red' : '');
  el.innerText = `${card.value}${card.suit}`;
  return el;
}
function makeBackElement(){ const el=document.createElement('div'); el.className='card back'; return el; }

function makePileCardElement(card, idx, isTop){
  const el = document.createElement('div');
  el.className = 'pile-card' + ((card.suit==='â™¥'||card.suit==='â™¦') ? ' red' : '');
  el.innerText = `${card.value}${card.suit}`;
  const vOffset = Math.min(idx * 6, 80);
  const hOffset = Math.min(idx * 4, 40);
  el.style.top = (vOffset) + 'px';
  el.style.left = (hOffset) + 'px';
  el.style.zIndex = isTop ? 5000 + idx : 1000 + idx;
  if(isTop) el.classList.add('top');
  return el;
}

/* ---------- Flipped (top face-down) rendering ---------- */
function renderFlipped(){
  // CPU flipped: show exactly the cards in players[1].flipped as backs
  const cpuFlipped = document.getElementById('cpu-flipped');
  cpuFlipped.innerHTML = '';
  players[1].flipped.forEach(()=> cpuFlipped.appendChild(makeBackElement()));

  // Player flipped: show backs, clickable only when in flipped phase (hand empty & faceup empty)
  const playerFlipped = document.getElementById('player-flipped');
  playerFlipped.innerHTML = '';
  const p = players[0];
  players[0].flipped.forEach((card, idx) => {
    const back = makeBackElement();
    const inFlipPhase = !isPreGame && p.hand.length === 0 && p.faceup.length === 0 && !awaitingRestart && !gameOver;
    if(inFlipPhase && currentPlayer === 0){
      back.classList.add('hidden-clickable');
      back.onclick = () => playFlippedCard(idx);
    }
    playerFlipped.appendChild(back);
  });
}
/* ---------- Faceup (middle visible) rendering ---------- */
function renderFaceup() {
    // CPU faceup: visible cards (players[1].faceup), CPU does not allow clicks
    const cpuFaceup = document.getElementById('cpu-faceup');
    cpuFaceup.innerHTML = '';
    players[1].faceup.forEach(card => cpuFaceup.appendChild(makeCardElement(card)));

    // Player faceup: visible and clickable
    const playerFaceup = document.getElementById('player-faceup');
    playerFaceup.innerHTML = '';
    const p = players[0];

    p.faceup.forEach((card, idx) => {
        const el = makeCardElement(card);

        if (isPreGame) {
            // Pre-game swap logic
            el.style.cursor = 'pointer';
            el.onclick = () => {
                if (selectedSwapFaceup === idx) selectedSwapFaceup = null;
                else selectedSwapFaceup = idx;
                renderAll();
            };
            if (selectedSwapFaceup === idx) el.classList.add('swap-selected');
        } else {
            // Normal gameplay logic: clicking faceup cards when hand is empty
            if (!isPreGame && p.hand.length === 0 && !awaitingRestart && !gameOver && currentPlayer === 0) {
                el.classList.add('hidden-clickable');
                el.onclick = () => playFaceupCard(idx);
            }
        }

        playerFaceup.appendChild(el);
    });
}

 /* ---------- Player hand rendering ---------- */
function renderPlayer() {
    const div = document.getElementById('player-hand');
    div.innerHTML = '';
    const p = players[0];

    p.hand.forEach((card, i) => {
        const el = makeCardElement(card);

        if (isPreGame) {
            // Pre-game swap logic
            el.style.cursor = 'pointer';
            el.onclick = () => {
                if (selectedSwapHand === i) selectedSwapHand = null;
                else selectedSwapHand = i;
                renderAll();
            };
            if (selectedSwapHand === i) el.classList.add('swap-selected');
        } else {
            // Normal gameplay logic
            if (awaitingRestart && awaitingRestart.player === 0) el.classList.add('playable');
            else if (isPlayable(card)) el.classList.add('playable');

            el.style.cursor = 'pointer';
            el.onclick = () => {
                if (gameOver || currentPlayer !== 0) return;

                if (selectedIndices.includes(i)) {
                    selectedIndices = selectedIndices.filter(x => x !== i);
                } else {
                    if (selectedIndices.length > 0) {
                        const firstVal = players[0].hand[selectedIndices[0]].value;
                        if (card.value !== firstVal) {
                            setStatusOnce("You can only select cards of the same value.");
                            return;
                        }
                    } else {
                        if (!(awaitingRestart && awaitingRestart.player === 0) && !isPlayable(card)) {
                            setStatusOnce("That card is not playable now.");
                            return;
                        }
                    }
                    selectedIndices.push(i);
                }

                renderAll();
            };

            if (selectedIndices.includes(i)) el.classList.add('selected');
        }

        div.appendChild(el);
    });
}

 /* ---------- Pre-game swap hand & face-up ---------- */
document.getElementById('swapBtn').addEventListener('click', () => {
    if (!isPreGame) return;
    const p = players[0];
    if (selectedSwapHand == null || selectedSwapFaceup == null) {
        setStatusOnce("Select one hand card and one face-up card to swap.");
        return;
    }
    // Swap the selected cards
    const temp = p.hand[selectedSwapHand];
    p.hand[selectedSwapHand] = p.faceup[selectedSwapFaceup];
    p.faceup[selectedSwapFaceup] = temp;

    selectedSwapHand = null;
    selectedSwapFaceup = null;
    renderAll();
    setStatusOnce("Cards swapped! You can swap more or click Start Game.");
});


/* ---------- CPU hand render ---------- */
function renderCPU(){
  const div = document.getElementById('cpu-hand'); div.innerHTML = '';
  players[1].hand.forEach(()=> div.appendChild(makeBackElement()));
}

/* ---------- pile render ---------- */
function renderPile(){
  const div = document.getElementById('pile'); div.innerHTML = '';
  for(let i=0;i<pile.length;i++){
    div.appendChild(makePileCardElement(pile[i], i, i===pile.length-1));
  }
  document.getElementById('pile-count').innerText = `Pile: ${pile.length} card${pile.length===1?'':'s'}`;
}

function renderAll(){
  renderFlipped();
  renderFaceup();
  renderPlayer();
  renderCPU();
  renderPile();
  updateControls();
  checkWinner();
}

/* ---------- Controls ---------- */
function updateControls(){
    const swapBtn = document.getElementById('swapBtn');
    swapBtn.style.display = isPreGame ? 'inline-block' : 'none';

    const playBtn = document.getElementById('playBtn');
    const pickUpBtn = document.getElementById('pickupBtn');
    const startBtn = document.getElementById('startBtn');

    startBtn.style.display = isPreGame ? 'inline-block' : 'none';
    document.getElementById('deck').innerText = deck.length ? `Deck\n(${deck.length})` : 'Deck\n(0)';

    if(isPreGame){ playBtn.disabled = true; pickUpBtn.disabled = true; return; }
    if(gameOver || currentPlayer !== 0){ playBtn.disabled = true; return; }
    if(awaitingRestart && awaitingRestart.player === 0){ playBtn.disabled = (selectedIndices.length === 0); return; }
    if(selectedIndices.length === 0) playBtn.disabled = true;
    else {
        const selectedCards = selectedIndices.map(i => players[0].hand[i]);
        const allSame = selectedCards.every(c => c.value === selectedCards[0].value);
        playBtn.disabled = !allSame || !isPlayable(selectedCards[0]);
    }
    pickUpBtn.disabled = false;
}

/* ---------- Game rules ---------- */
function isPlayable(card){
  if(!card) return false;
  if(awaitingRestart) return false;
  const top = topCard();
  if(!top) return true;
  if(resetNext) return true;
  if(card.value === '10' || card.value === '2') return true;
  if(card.value === '7'){ return idxOf(top.value) <= idxOf('7'); }
  if(sevenConstraint && card.value !== '2' && card.value !== '10'){ return idxOf(card.value) <= idxOf('7'); }
  const cIdx = idxOf(card.value), tIdx = idxOf(top.value);
  return cIdx === tIdx || cIdx > tIdx;
}

/* ---------- Play selected (hand) ---------- */
document.getElementById('playBtn').addEventListener('click', ()=>{
  if(gameOver || currentPlayer!==0 || isPreGame) return;
  if(awaitingRestart && awaitingRestart.player===0){ confirmHumanRestart(); return; }
  if(selectedIndices.length===0) return setStatusOnce("Select card(s) first.");
  playSelectedHuman();
});
function playSelectedHuman(){
  selectedIndices.sort((a,b)=>b-a);
  const cards = selectedIndices.map(i=>players[0].hand[i]);
  const val = cards[0].value;
  if(!cards.every(c=>c.value===val)){ selectedIndices = []; renderAll(); return; }

  if(val === '10'){
    selectedIndices.forEach(i => players[0].hand.splice(i,1));
    pile = [];
    renderAll(); refill(0);
    awaitingRestart = { player: 0 };
    selectedIndices = [];
    setStatusOnce("You bombed the pile â€” select 1+ same-value cards to restart.");
    return;
  }

  selectedIndices.forEach(i => pile.push(players[0].hand.splice(i,1)[0]));
  resetNext = (val === '2');
  sevenConstraint = (val === '7');
  selectedIndices = [];
  renderAll();
  refill(0);
  nextTurn();
}

/* ---------- Confirm restart ---------- */
function confirmHumanRestart(){
  if(!awaitingRestart || awaitingRestart.player !== 0) return;
  if(selectedIndices.length === 0) return setStatusOnce("Select at least one card to restart the pile.");
  selectedIndices.sort((a,b)=>b-a);
  const cards = selectedIndices.map(i=>players[0].hand[i]);
  const val = cards[0].value;
  if(!cards.every(c=>c.value===val)){ selectedIndices = []; renderAll(); return setStatusOnce("All restart cards must match."); }

  selectedIndices.forEach(i=> pile.push(players[0].hand.splice(i,1)[0]));
  resetNext = (val === '2'); sevenConstraint = (val === '7');
  awaitingRestart = null; selectedIndices = [];
  renderAll(); refill(0); nextTurn();
}

/* ---------- Play a visible faceup card (player) ---------- */
function playFaceupCard(idx){
  const p = players[0];
  if(isPreGame || currentPlayer!==0 || gameOver) return;
  if(p.hand.length !== 0) return setStatusOnce("Finish your hand before using face-up cards.");
  if(idx < 0 || idx >= p.faceup.length) return;
  const card = p.faceup.splice(idx,1)[0];
  if(!card) return;

  if(isPlayable(card)){
    pile.push(card);
    resetNext = (card.value === '2'); sevenConstraint = (card.value === '7');
    renderAll(); setStatusOnce("Played a face-up card."); nextTurn();
  } else {
    // can't beat -> pick up pile
    p.hand.push(card);
    while(pile.length > 0) {
        p.hand.push(pile.shift());
    }
    /*
    if(pile.length > 0){ p.hand.push(...pile); pile = []; }
    */
    renderAll();
    setStatusOnce("Face-up card couldn't be played â€” you picked up the pile.");
    nextTurn();
  }
}

/* ---------- Play a face-down flipped card (player final phase) ---------- */
function playFlippedCard(idx){
  const p = players[0];
  if(isPreGame || currentPlayer!==0 || gameOver) return;
  // only allowed when no hand and no faceup
  if(p.hand.length !== 0 || p.faceup.length !== 0) return;
  if(idx < 0 || idx >= p.flipped.length) return;
  const card = p.flipped.splice(idx,1)[0];
  if(!card) return;

  if(isPlayable(card)){
    pile.push(card);
    resetNext = (card.value === '2'); sevenConstraint = (card.value === '7');
    renderAll();
    setStatusOnce("You revealed and played a flipped card.");
    nextTurn();
  } else {
    p.hand.push(card);
    if(pile.length > 0){ p.hand.push(...pile); pile = []; }
    renderAll();
    setStatusOnce("Revealed flipped card cannot be played â€” you picked up the pile.");
    nextTurn();
  }
}


/* ---------- Pick up pile ---------- */
document.getElementById('pickupBtn').addEventListener('click', ()=>{
  if (gameOver || currentPlayer !== 0 || isPreGame) return;
  if (pile.length === 0) return setStatusOnce("Pile is empty.");
  const p = players[0];
  p.hand.push(...pile);
  pile = [];
  refill(0);
  renderAll();
  setStatusOnce("You picked up the pile.");
  nextTurn();
});

/* ---------- Deck draw ---------- */
document.getElementById('deck').addEventListener('click', ()=>{
  if(gameOver || currentPlayer!==0 || isPreGame || awaitingRestart) return;
  const p = players[0];
  if(p.hand.length >= 3) return setStatusOnce("Hand is full.");
  if(deck.length === 0) return setStatusOnce("Deck empty.");
  p.hand.push(deck.pop());
  renderAll();
});

/* ---------- Turn & CPU ---------- */
function nextTurn(){
  if(checkWinner()) return;
  selectedIndices = [];
  currentPlayer = 1;
  setStatusOnce("CPU thinking...");
  setTimeout(cpuTurn, 450);
}

function cpuIsPlayable(card){
  if(!card) return false;
  if(awaitingRestart) return false;
  const top = topCard();
  if(!top) return true;
  if(resetNext) return true;
  if(card.value === '10' || card.value === '2') return true;
  if(card.value === '7') return idxOf(top.value) <= idxOf('7');
  if(sevenConstraint && card.value!=='2' && card.value!=='10') return idxOf(card.value) <= idxOf('7');
  return idxOf(card.value) === idxOf(top.value) || idxOf(card.value) > idxOf(top.value);
}

function cpuTurn(){
  if(gameOver) return;
  const cpu = players[1];

  // If CPU has empty hand but has faceup cards -> play from faceup first
  if(cpu.hand.length === 0 && cpu.faceup.length > 0 && !awaitingRestart){
    // choose last faceup for simplicity
    const card = cpu.faceup.pop();
    if(card){
      if(cpuIsPlayable(card)){
        pile.push(card);
        resetNext = (card.value === '2'); sevenConstraint = (card.value === '7');
        renderAll();
        currentPlayer = 0; setStatusOnce("CPU played a face-up card. Your turn."); return;
      } else {
        cpu.hand.push(card);
        if(pile.length>0){ cpu.hand.push(...pile); pile = []; }
        refill(1); renderAll();
        currentPlayer = 0; setStatusOnce("CPU couldn't play a face-up card and picked up the pile. Your turn."); return;
      }
    }
  }

  // If no faceup and cpu has flipped (final phase), reveal one flipped automatically
  if(cpu.hand.length === 0 && cpu.faceup.length === 0 && cpu.flipped.length > 0 && !awaitingRestart){
    const card = cpu.flipped.pop();
    if(card){
      if(cpuIsPlayable(card)){
        pile.push(card);
        resetNext = (card.value === '2'); sevenConstraint = (card.value === '7');
        renderAll();
        currentPlayer = 0; setStatusOnce("CPU revealed and played a flipped card. Your turn."); return;
      } else {
        cpu.hand.push(card);
        if(pile.length>0){ cpu.hand.push(...pile); pile = []; }
        refill(1); renderAll();
        currentPlayer = 0; setStatusOnce("CPU revealed flipped card and picked up the pile. Your turn."); return;
      }
    }
  }

  // Refill if needed
  if(cpu.hand.length === 0 && (cpu.faceup.length > 0 || deck.length > 0 || cpu.flipped.length > 0)){ refill(1); renderAll(); }

  // If awaiting restart for CPU
  if(awaitingRestart && awaitingRestart.player===1){
    if(cpu.hand.length > 0){
      const group = {};
      for(let i=0;i<cpu.hand.length;i++){ const v = cpu.hand[i].value; if(!group[v]) group[v]=[]; group[v].push(i); }
      const groups = Object.keys(group).sort((a,b)=> group[b].length - group[a].length || idxOf(a)-idxOf(b));
      const chosenVal = groups[0];
      const inds = group[chosenVal].sort((a,b)=>b-a);
      inds.forEach(i => pile.push(cpu.hand.splice(i,1)[0]));
      resetNext = (chosenVal === '2'); sevenConstraint = (chosenVal === '7');
    }
    awaitingRestart = null; refill(1); renderAll(); currentPlayer = 0; setStatusOnce("Your turn"); return;
  }

  // Build playable indices
  const playableIdx = [];
  for(let i=0;i<cpu.hand.length;i++) if(cpuIsPlayable(cpu.hand[i])) playableIdx.push(i);

  // If none playable => pick up pile
  if(playableIdx.length === 0){
    if(pile.length > 0){
      cpu.hand.push(...pile); pile = []; refill(1); renderAll(); currentPlayer = 0; setStatusOnce("CPU picked up the pile. Your turn."); return;
    } else { refill(1); renderAll(); currentPlayer = 0; setStatusOnce("CPU has no playable cards. Your turn."); return; }
  }

  // Bomb handling
  const tensIdx = playableIdx.filter(i => cpu.hand[i].value === '10');
  if(tensIdx.length > 0){
    tensIdx.sort((a,b)=>b-a).forEach(i => pile.push(cpu.hand.splice(i,1)[0]));
    pile = []; renderAll();
    if(cpu.hand.length > 0){
      const group = {};
      for(let i=0;i<cpu.hand.length;i++){ const v = cpu.hand[i].value; if(!group[v]) group[v]=[]; group[v].push(i); }
      const groups = Object.keys(group).sort((a,b)=> group[b].length - group[a].length || idxOf(a)-idxOf(b));
      const chosenVal = groups[0];
      const inds = group[chosenVal].sort((a,b)=>b-a);
      inds.forEach(i => pile.push(cpu.hand.splice(i,1)[0]));
      resetNext = (chosenVal === '2'); sevenConstraint = (chosenVal === '7');
    } else { resetNext = false; sevenConstraint = false; }
    refill(1); renderAll(); currentPlayer = 0; setStatusOnce("CPU bombed the pile and restarted. Your turn."); return;
  }

  // Normal CPU play
  const groups = {};
  playableIdx.forEach(i=>{ const v = cpu.hand[i].value; if(!groups[v]) groups[v]=[]; groups[v].push(i); });
  const vals = Object.keys(groups).sort((a,b)=> groups[b].length - groups[a].length || idxOf(a) - idxOf(b));
  const chosenVal = vals[0];
  const inds = groups[chosenVal].sort((a,b)=>b-a);
  inds.forEach(i => pile.push(cpu.hand.splice(i,1)[0]));
  resetNext = (chosenVal === '2'); sevenConstraint = (chosenVal === '7');

  refill(1); renderAll(); currentPlayer = 0; setStatusOnce("Your turn");
}

// Check for 4-of-a-kind bomb: last 4 consecutive cards must have the same value
function checkFourConsecutiveBomb() {
    if(pile.length < 4) return false;
    const lastFour = pile.slice(-4);
    const val = lastFour[0].value;
    // All 4 must be same value
    return lastFour.every(c => c.value === val);
}

// Example usage in human play:
function playSelectedHuman(){
    selectedIndices.sort((a,b)=>b-a);
    const cards = selectedIndices.map(i=>players[0].hand[i]);
    const val = cards[0].value;
    if(!cards.every(c=>c.value===val)){ selectedIndices = []; renderAll(); return; }

    // Normal 10-bomb
    if(val === '10'){
        selectedIndices.forEach(i => players[0].hand.splice(i,1));
        pile = [];
        renderAll(); refill(0);
        awaitingRestart = { player: 0 };
        selectedIndices = [];
        setStatusOnce("You bombed the pile â€” select 1+ same-value cards to restart.");
        return;
    }

    // Play cards normally
    selectedIndices.forEach(i => pile.push(players[0].hand.splice(i,1)[0]));
    resetNext = (val === '2');
    sevenConstraint = (val === '7');
    selectedIndices = [];
    renderAll();
    refill(0);

    // Check for 4-of-a-kind bomb
    if(checkFourConsecutiveBomb()){
        pile = [];
        awaitingRestart = { player: 0 };
        setStatusOnce("4-of-a-kind bomb! You may play any card to restart the pile.");
        renderAll();
        return;
    }

    nextTurn();
}

/* ---------- Winner & status ---------- */
function checkWinner(){
  for(let i=0;i<players.length;i++){
    const p = players[i];
    if(p.hand.length===0 && p.faceup.length===0 && p.flipped.length===0){
      gameOver = true;
      document.getElementById('winner').innerText = (i===0) ? "You win! ðŸŽ‰" : "CPU wins.";
      setStatusOnce("Game over.");
      return true;
    }
  }
  document.getElementById('winner').innerText = "";
  return false;
}

let statusTimeout = null;
function setStatusOnce(msg){
  clearTimeout(statusTimeout);
  const extra = awaitingRestart ? " (restart: play 1+ same-value)" : (resetNext ? " (previous was 2 â€” next may play anything)" : (sevenConstraint ? " (previous was 7 â€” next must play â‰¤7 or play 2/10)" : ""));
  document.getElementById('status').innerText = msg + extra;
  statusTimeout = setTimeout(()=>{}, 200);
}

/* ---------- Buttons ---------- */
document.getElementById('startBtn').addEventListener('click', ()=>{
  isPreGame = false; renderAll(); setStatusOnce("Your turn â€” play card(s) or pick up pile.");
});
document.getElementById('newBtn').addEventListener('click', ()=> startGame());

/* ---------- Init ---------- */
startGame();
</script>
</body>
</html>